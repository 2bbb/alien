<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title></title>
<meta name="author" content="Customer">
<meta name="editor" content="html-editor phase 5">
</head>
<body text="#7070FF" bgcolor="#00001b" link="#FF0000" alink="#FF0000" vlink="#FF0000">
    <table>
    <tr> <td width="800">
        <font face="Courier" color="#E0FFB0" size="4">
        <p>
            <img src="qrc:///tutorial/logo.png" alt="logo" width="800">
            <br />
            <i>alien</i> is a shortform for `artificial life environment'
            and denotes a research tool aiming to simulate digital organisms in an artificial ecosystem and (pre-)biotic evolution.
            The main feature is that it combines a realistic physical framework including kinematic and thermodynamic processes
            for the simulated world with a computational model that allows to describe the behavior and purposeful interventions of the organisms.
            In this document an overview of the underlying model and the simulation software is given.
        </p>
        </font>
        <font face="Courier" color="#B0D0B0">
            <p>
                <h2> Content</h2>
            </p>
        </font>
            <p>
            <h3> <a href="#introduction"><font face="Courier" color="#FFFFFF">1 Introduction</font></a></h3>
            <h3> <a href="#alienmodel"><font face="Courier" color="#FFFFFF">2 alien model</font></a></h3>
            <h3> <a href="#physics"><font face="Courier" color="#FFFFFF">2.1 Physics</font></a></h3>
            <h3> <a href="#rigidbody"><font face="Courier" color="#FFFFFF">2.1.1 Rigid body motion</font></a></h3>
            <h3> <a href="#thermodynamics"><font face="Courier" color="#FFFFFF">2.1.2 Thermodynamics</font></a></h3>
            <h3> <a href="#space"><font face="Courier" color="#FFFFFF">2.1.3 Space</font></a></h3>
            <h3> <a href="#entities"><font face="Courier" color="#FFFFFF">2.1.4 Entities</font></a></h3>
            <h3> <a href="#cell"><font face="Courier" color="#FFFFFF">2.1.4.1 Cell</font></a></h3>
            <h3> <a href="#cellcluster"><font face="Courier" color="#FFFFFF">2.1.4.2 Cell cluster</font></a></h3>
            <h3> <a href="#energyparticle"><font face="Courier" color="#FFFFFF">2.1.4.3 Energy particle</font></a></h3>
            <h3> <a href="#token"><font face="Courier" color="#FFFFFF">2.1.4.4 Token</font></a></h3>
            <h3> <a href="#programmablematter"><font face="Courier" color="#FFFFFF">2.2 Information processing model</font></a></h3>
            <h3> <a href="#processingscheme"><font face="Courier" color="#FFFFFF">2.2.1 Processing scheme</font></a></h3>
            <h3> <a href="#cellfunctions"><font face="Courier" color="#FFFFFF">2.2.2 Cell function programming</font></a></h3>
            <h3> <a href="#computer"><font face="Courier" color="#FFFFFF">2.2.2.1 Computer</font><a></h3>
            <h3> <a href="#propulsion"><font face="Courier" color="#FFFFFF">2.2.2.2 Propulsion</font><a></h3>
            <h3> <a href="#scanner"><font face="Courier" color="#FFFFFF">2.2.2.3 Scanner</font><a></h3>
            <h3> <a href="#weapon"><font face="Courier" color="#FFFFFF">2.2.2.4 Weapon</font><a></h3>
            <h3> <a href="#constructor"><font face="Courier" color="#FFFFFF">2.2.2.5 Constructor</font><a></h3>
            <h3> <a href="#sensor"><font face="Courier" color="#FFFFFF">2.2.2.6 Sensor</font><a></h3>
            <h3> <a href="#energyguidance"><font face="Courier" color="#FFFFFF">2.3 Energy guidance system</font></a></h3>
            <h3> <a href="#globalparameters"><font face="Courier" color="#FFFFFF">2.4 Global parameters</font></a></h3>
            <h3> <a href="#simulator"><font face="Courier" color="#FFFFFF">3 alien simulator</font></a></h3>
            <h3> <a href="#conductingsimulations"><font face="Courier" color="#FFFFFF">3.1 Conducting simulations</font></a></h3>
            <h3> <a href="#simulationparameters"><font face="Courier" color="#FFFFFF">3.1.1 Simulation parameters</font></a></h3>
            <h3> <a href="#metadata"><font face="Courier" color="#FFFFFF">3.1.2 Metadata</font></a></h3>
            <h3> <a href="#views"><font face="Courier" color="#FFFFFF">3.2 Views and manipulation tools</font></a></h3>
            <h3> <a href="#macroview"><font face="Courier" color="#FFFFFF">3.2.1 Macroscopic view</font></a></h3>
            <h3> <a href="#microview"><font face="Courier" color="#FFFFFF">3.2.2 Microscopic view</font></a></h3>
            <h3> <a href="#celleditor"><font face="Courier" color="#FFFFFF">3.2.2.1 Cell editor</font></a></h3>
            <h3> <a href="#tokeneditor"><font face="Courier" color="#FFFFFF">3.2.2.2 Token editor</font></a></h3>
            <h3> <a href="#ensembles"><font face="Courier" color="#FFFFFF">3.3 Managing ensembles</font></a></h3>
            <h3> <a href="#monitoring"><font face="Courier" color="#FFFFFF">3.4 Monitoring</font></a></h3>
        </p>
        <font face="Courier" color="#70B070">
            <p>
                <br />
                <h2 id="introduction">1 Introduction</h2>
            </p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                <i>alien</i> is a shortform for `artificial life environment'
                and denotes a research tool aiming to simulate digital organisms in an artificial ecosystem and (pre-)biotic evolution.
                The main feature is that it combines a realistic physical framework including kinematic and thermodynamic processes
                for the simulated world with a computational model that allows to describe the behavior and purposeful interventions of the organisms.
                The organisms form <i>cell clusters</i>, which are modeled by planary graphs where the nodes corresponds to elementary <i>cells</i>
                and the edges to communication channels (<i>connections</i>).
                In the following we briefly explain the underlying computational as well as the physical model:
                <br />
                <br />
                <b>Information processing model:</b>
                Cell clusters implement their behavior algorithms in the cells and their connections.
                The topology of the cluster allows to implement loops, branches, distributed algorithm etc.
                Computations as well as input and output operations of the clusters are performed on the <i>cells</i> via <i>tokens</i>.
                Every token contains a memory and provokes execution of <i>cell functions</i>.
                Various cell functions such as computations, sensoring, constructing, attacking external cells etc. are available.
                After a cell has executed its function the token spreads to adjacent cells by a specific rule.
                This will be decided on the basis of the <i>branch number</i> attributed to every token and cell.
                The rule is that the token spreads to an adjacent cell if the branch number of the cell is one larger
                than the token branch number modulo a fixed constant (see <i>[cell properties]->[max token branch number]</i>).
                <br />
                <br />
                <b>Physical model:</b>
                Every cell cluster is embedded into a physical 2D space and performs rigid body motions.
                They possess associated linear and angular momentums.
                If two clusters collide they may merge provided the velocities are high enough (see <i>[cell properties]->[fusion velocity]</i>)
                and the touching cells on both clusters are able to form bonds (see <i>[cell properties]->[max bonds]</i>).
                Otherwise a collision takes place.
                Single cells of a cluster might be destroyed after a collision if the forces exceeds a certain threshold (see <i>[cell properties]->[max force]</i>).
                Furthermore cells as well as tokens have internal energy value and
                emit <i>energy particles</i> from time to time.
                Radiation lowers their internal energy and may finally lead to disintegration.
                But if on the contrary energy particles collide they may form a new cell if their energy values together are high enough.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="alienmodel">2 alien model</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                The alien model combines a physical and a computation model and can be seen some realization of artificial programmable matter.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="physics">2.1 Physics</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="rigidbody">2.1.1 Rigid body motion</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                A motion of the cell clusters is calculated via rigid body dynamics.
                Thus every cluster performs a linear movement and a rotation with respect to its center position.
                Collision of two clusters result in one of the following scenario: cluster fusion or collision.
                The former case takes place if the relative velocities of the touching cells exceeds the fusion velocity
                and if each cell is able to establish new bonds.
                In the fusion process kinetic energy is transformed into internal energy
                whereas the linear and angular momentum is preserved.
                In the latter case a rigid collision is conducted, which preserves the overall kinetic energy (rotation and linear part)
                of the involving objects.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="thermodynamics">2.1.2 Thermodynamics</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                Each cell object looses internal energy through radiation.
                This process is realized by emitting energy particles to its environment.
                These particles have a velocity but no mass and they carry a specific amount of energy.
                Whenever the internal energy of a cell is below some value (see <i>[cell properties]->[min value]</i>)
                it becomes unstable and transforms itself into an energy particle.
                It may also lead to a destruction of the superordinate cell cluster into two or more separated parts.
                If two energy particles collide they form a single particle with the combined energy.
                When the amount of energy exceeds a given value needed to form a cell (see <i>[cell properties]->[min value]</i>)
                and its kinetic energy, the particle transforms with a fixed probability (see <i>[cell properties]->[transformation probability]</i>)
                into a cell.
                Therefore dynamic creation and destruction processes of cells are implemented.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="space">2.1.3 Space</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                Every cell cluster and energy particle object is embedded in a common space where all the physical actions take place.
                Topologically the space is 2D torus, which means that the opposite boundaries are to be considered as the same.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="entities">2.1.4 Entities</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="cell">2.1.4.1 Cell</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                The cells are the main entities in alien.
                They have a position in space, an internal energy value,
                they can establish bonds with other cells, and, moreover,
                they have an associated cell function and may store tokens.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="cellcluster">2.1.4.2 Cell cluster</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                Cells are able to form bonds with other cells (see <i>[cell properties]->[max bonds]</i>).
                Cell clusters are simply set of cells connected together.
                Physically they rotate and move with respect to their center position.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="energyparticles">2.1.4.3 Energy particle</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                This type of entity carries energy through space.
                It moves with a particular velocity but has no mass.
                Energy particle can fuse if they collide together and
                be absorbed if they collisde with cells.
                Furthermore every cell emits energy particle from time to time and thus looses
                internal energy.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="token">2.1.4.4 Token</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                Token are used to coordinate the information processing
                capability of the cells.
                They carry a memory storage and have an internal energy.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="programmablematter">2.2 Information processing model</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="processingscheme">2.2.1 Processing scheme</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                The cells feature information processing capabilities.
                As soon as a token passes a cell the specific cell function
                is invoked (see next section for more details).
                During this process memory of the cell as well as of the token
                might be changed. Also certain physical operations might be performed.
                After the cell function has finished its processing the token
                invokes its <i>energy guidance system</i>, increments its so-called
                <i>branch number</i> and spreads to adjacent cells
                that possess the same branch number. Hence cells and tokens have associated
                branch numbers that might change during processing.
                The branch number is incremented by using a modulo arithmetic, see
                <i>[cell properties]->[max token branch number]</i>.
                If there are more than one cells to be considered the token is duplicated
                and the required energy is consumed from the cells.
                By making use of duplicating tokens parallel algorithms can be implemented.
                If there is no cell on which the token can pass the token will be destroyed
                and its internal energy is transferred to the current cell.
                <br />
                The token branching is illustrated in the picture below.
                It shows token spreading on certain cells which are part of a cluster.
                The branch numbers are revealed for the cells and the tokens (red circles) before invoking the cell function.
                In this example
                the tokens possess the same branch number as the underlying cell.
                However the cell function may change this number if desired (this is not the case in the example).
                In this way the token branching can be controlled.
                <br />
                <br />
                <img src="qrc:///tutorial/branching.png" alt="logo" width="800">
                <br />
                <br />
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="cellfunctions">2.2.2 Cell function programming</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="computer">2.2.2.1 Computer</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                The `computer cell function' provides different types of computations and is programmed by machine code.
                The machine code is stored in the cell and their instructions can access the memory storage of the cell as well as of the token.
                Both memory storages can have a masximum size of 256 bytes and all variables and addresses are one byte long.
                In calculations all values are interpreted as 8 bit signed integers.
                The number of instructions a `computer cell function' can have is indicated in
                <i>[cell properties]->[computer]->[max instructions]</i>,
                the size of the cell memory in <i>[cell properties]->[computer]->[cell memory size]</i>
                and the size of the token memory in <i>[cell properties]->[computer]->[token memory size]</i>.
                <br />
                Each instruction consists of three bytes (3x8=24 bits) with the following assigment
                <br />
                <table border="1">
                 <tr>
                  <th>23</th>
                  <th>22</th>
                  <th>21</th>
                  <th>20</th>
                  <th>19</th>
                  <th>18</th>
                  <th>17</th>
                  <th>16</th>
                  <th>15</th>
                  <th>14</th>
                  <th>13</th>
                  <th>12</th>
                  <th>11</th>
                  <th>10</th>
                  <th>9</th>
                  <th>8</th>
                  <th>7</th>
                  <th>6</th>
                  <th>5</th>
                  <th>4</th>
                  <th>3</th>
                  <th>2</th>
                  <th>1</th>
                  <th>0</th>
                 </tr>
                 <tr>
                 <td colspan="4"> opcode </td>
                 <td colspan="2"> opType1 </td>
                 <td colspan="2"> opType2 </td>
                 <td colspan="8"> opValue1 </td>
                 <td colspan="8"> opValue2</td>
                 </tr>
                </table>
                <br />
                <br />
                with the following values for opcode
                <br />
                <table border="1">
                 <tr>
                  <th> opcode </th>
                  <th> symbolic name </th>
                  <th> description </th>
                 </tr>
                 <tr>
                  <td> 0 </td>
                  <td> mov </td>
                  <td> copy operand: op1 := op2 </td>
                 </tr>
                 <tr>
                  <td> 1 </td>
                  <td> add </td>
                  <td> add operands: op1 := op1 + op2 </td>
                 </tr>
                 <tr>
                  <td> 2 </td>
                  <td> sub </td>
                  <td> subtract operands: op1 := op1 - op2 </td>
                 </tr>
                 <tr>
                  <td> 3 </td>
                  <td> mul </td>
                  <td> multiply operands: op1 := op1 * op2 </td>
                 </tr>
                 <tr>
                  <td> 4 </td>
                  <td> div </td>
                  <td> divide operands: op1 := op1 / op2 </td>
                 </tr>
                 <tr>
                  <td> 5 </td>
                  <td> xor </td>
                  <td> bitwise XOR of operands: op1 := op1 XOR op2 </td>
                 </tr>
                 <tr>
                  <td> 6 </td>
                  <td> or </td>
                  <td> bitwise OR of operands: op1 := op1 OR op2 </td>
                 </tr>
                 <tr>
                  <td> 7 </td>
                  <td> and </td>
                  <td> bitwise AND of operands: op1 := op1 AND op2 </td>
                 </tr>
                 <tr>
                  <td> 8 </td>
                  <td> if op1 > op2 </td>
                  <td> compare if operand1 is greater than operand2 </td>
                 </tr>
                 <tr>
                  <td> 9 </td>
                  <td> if op1 >= op2 </td>
                  <td> compare if operand1 is greater or equal than operand2 </td>
                 </tr>
                 <tr>
                  <td> 10 </td>
                  <td> if op1 = op2 </td>
                  <td> compare if operand1 is equal to operand2 </td>
                 </tr>
                 <tr>
                  <td> 11 </td>
                  <td> if op1 != op2 </td>
                  <td> compare if operand1 is not equal to operand2 </td>
                 </tr>
                 <tr>
                  <td> 12 </td>
                  <td> if op1 &lt;= op2 </td>
                  <td> compare if operand1 is less or equal than operand2</td>
                 </tr>
                 <tr>
                  <td> 13 </td>
                  <td> if op1 &lt; op2</td>
                  <td> compare if operand1 is less than operand2</td>
                 </tr>
                 <tr>
                  <td> 14 </td>
                  <td> else </td>
                  <td> invoke else-clause in comparison </td>
                 </tr>
                 <tr>
                  <td> 15 </td>
                  <td> endif</td>
                  <td> finish comparison</td>
                 </tr>
                 </table>
                 <br />
                 <br />
                 opValue1 and opValue2 refer to 8 bit values with
                 a variable meaning determined by opType1 and opType2, respectively.
                 Note that there are no instructions for loops. They can be realized
                 with circular constructions of cell connections.
                 <br />
                 <table border="1">
                 <tr>
                  <th> opType1 </th>
                  <th> symbolic name </th>
                  <th> description </th>
                 </tr>
                 <tr>
                  <td> 0 or 3</td>
                  <td> [opValue1] </td>
                  <td> operand1 points to a byte in token memory </td>
                 </tr>
                 <tr>
                  <td> 1 </td>
                  <td> [[opValue1]] </td>
                  <td> operand1 points to a pointer to a byte in token memory </td>
                 </tr>
                 <tr>
                  <td> 2 </td>
                  <td> (opValue1) </td>
                  <td> operand1 points to a byte in cell memory  </td>
                 </tr>
                 </table>
                 <br />
                 <br />
                 <table border="1">
                  <tr>
                  <th> opType2</th>
                  <th> symbolic name </th>
                  <th> description </th>
                  </tr>
                  <tr>
                   <td> 0 </td>
                   <td> [opValue2] </td>
                   <td> operand2 points to a byte in token memory </td>
                  </tr>
                  <tr>
                   <td> 1 </td>
                   <td> [[opValue2]] </td>
                   <td> operand2 points to a pointer to a byte in token memory </td>
                  </tr>
                  <tr>
                   <td> 2 </td>
                   <td> (opValue2) </td>
                   <td> operand2 points to a byte in cell memory  </td>
                  </tr>
                  <tr>
                   <td> 3 </td>
                   <td> opValue2 </td>
                   <td> operand2 is a constant </td>
                  </tr>
                 </table>
                 <br />
                 <br />
                 <font face="Courier" color="#FFFFB0" size="4">
                    <strong>Examples</strong>
                 </font>
                 <br />
                 Let us give some examples in the more readable assembler notation
                 (hexadecimal values are preceded by 0x).
                 <br />
                 <table border="1">
                 <tr>
                  <th> assembler notation </th>
                  <th> description </th>
                  <th> opcode </th>
                  <th> opType1 </th>
                  <th> opType2 </th>
                  <th> opValue1 </th>
                  <th> opValue2 </th>
                  <th> hex code </th>
                 </tr>
                 <tr>
                  <td> mov (128), 10 </td>
                  <td> copy the value 10 to cell memory at address 128 </td>
                  <td> 0 </td>
                  <td> 2 </td>
                  <td> 3 </td>
                  <td> 128 </td>
                  <td> 10 </td>
                  <td> 0x0B800A </td>
                 </tr>
                 <tr>
                  <td> mul (32), [[64]] </td>
                  <td> multiply the value from cell memory at address 32 with the value from token memory at the address that is found in token memory at address 64</td>
                  <td> 3 </td>
                  <td> 2 </td>
                  <td> 1 </td>
                  <td> 32 </td>
                  <td> 64 </td>
                  <td> 0x392040 </td>
                 </tr>
                </table>
                <br />
                <br />
                A simple cell program consisting of 5 instructions may look like as follows:
                <br />
                if [10] = (0)
                <br />
                &nbsp;&nbsp;mov [10], 0
                <br />
                else
                <br />
                &nbsp;&nbsp;add [10], 1
                <br />
                endif
                <br />
                <br />
                On the first line it is checked if the content of token memory at address 10 equals
                the content of cell memory at address 0.
                If this is true the content of token memory at address 10 is set to 0
                otherwise it is incremented by 1.
                <br />
                A `computer cell function' stores <i>n</i> instructions where
                <i>n</i> is specified by
                <i>[cell function properties]->[computer]->[max instructions]</i>.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="propulsion">2.2.2.2 Propulsion</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                A controlled acceleration can be performed by the `propulsion cell function'.
                It uses three input bytes and produces
                one output byte. Both are read and stored in the token memory.
                Their addresses depend on the implementation.
                In the following we introduce symbolic names for them.
                <br />
                <table border="1">
                 <tr>
                  <th>
                   byte name
                  </th>
                  <th>
                   type
                  </th>
                  <th>
                   description
                  </th>
                 </tr>
                 <tr>
                  <td>
                   PROP_OUT
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the state of the after the process (see below)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   PROP_IN
                  </td>
                  <td>
                    input byte
                  </td>
                  <td>
                   contains the command (see below)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   PROP_IN_ANGLE
                  </td>
                  <td>
                   input byte
                  </td>
                  <td>
                   contains CODED_ANGLE(alpha) where alpha is the
                   angle in which the acceleration takes place
                  </td>
                 </tr>
                 <tr>
                  <td>
                   PROP_IN_POWER
                  </td>
                  <td>
                   input byte
                  </td>
                  <td>
                   determines the intensity of the acceleration
                  </td>
                 </tr>
                </table>
                <br />
                <br />
                The direction of acceleration is determined by the command
                PROP_IN and possibly by PROP_IN_ANGLE.
                All angles are always measured clockwise with respect
                to the axis given by the invoked cell and the cell where the token came from (see picture below).
                <br />
                <br />
                <img src="qrc:///tutorial/angle.png" alt="logo" width="200">
                <br />
                <br />
                The function CODED_ANGLE above transforms an angle from degree into an 8 bit representations.
                More precisely, angles from 0 to 179 degree are mapped to 0 until 128 (dec) and
                the angles from -180 to 0 degree are mapped to 128 until 256 (= 0).
                <br />
                PROP_IN may take the following values.
                <br />
                <table border="1">
                 <tr>
                  <th>
                   values of PROP_IN
                   <br />
                   (modulo 7)
                  </th>
                  <th>
                   symbolic name
                  </th>
                  <th>
                   description
                  </th>
                 </tr>
                 <tr>
                  <td>
                   0
                  </td>
                  <td>
                   PROP_IN::NOTHING
                  </td>
                  <td>
                   do nothing
                  </td>
                 </tr>
                 <tr>
                  <td>
                   1
                  </td>
                  <td>
                   PROP_IN::BY_ANGLE
                  </td>
                  <td>
                   accelerate in direction specified by the angle in PROP_IN_ANGLE
                  </td>
                 </tr>
                 <tr>
                  <td>
                   2
                  </td>
                  <td>
                   PROP_IN::FROM_CENTER
                  </td>
                  <td>
                   accelerate in the direction given by the vector posCell - posMassCenter (i.e. away from mass center) where
                   posMassCenter denotes position of the mass center of the current cell cluster and posCell the position of the invoked cell;
                  </td>
                 </tr>
                 <tr>
                  <td>
                   3
                  </td>
                  <td>
                   PROP_IN::TOWARD_CENTER
                  </td>
                  <td>
                   accelerate in the direction given by the vector posMassCenter - posCell (i.e. toward mass center; cf. above)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   4
                  </td>
                  <td>
                   PROP_IN::ROTATION_CLOCKWISE
                  </td>
                  <td>
                   accelerate in a direction that increases clockwise rotation
                  </td>
                 </tr>
                 <tr>
                  <td>
                   5
                  </td>
                  <td>
                   PROP_IN::ROTATION_COUNTERCLOCKWISE
                  </td>
                  <td>
                   accelerate in a direction that increases counterclockwise rotation
                  </td>
                 </tr>
                 <tr>
                  <td>
                   6
                  </td>
                  <td>
                   PROP_IN::DAMP_ROTATION
                  </td>
                  <td>
                   accelerate in a direction that decreases current rotation
                  </td>
                 </tr>
                </table>
                <br />
                <br />
                The output given in PROP_OUT can attain the values given below.
                <br />
                <table border="1">
                <tr>
                 <th>
                  values of PROP_OUT
                 </th>
                 <th>
                  symbolic name
                 </th>
                 <th>
                  description
                 </th>
                </tr>
                <tr>
                 <td>
                  0
                 </td>
                 <td>
                  PROP_OUT::SUCCESS
                 </td>
                 <td>
                  acceleration performed
                 </td>
                </tr>
                <tr>
                 <td>
                  1
                 </td>
                 <td>
                  PROP_OUT::SUCCESS_DAMPING_FINISHED
                 </td>
                 <td>
                  rotation of the cluster is approximately 0, no further damping possible
                 </td>
                </tr>
                <tr>
                 <td>
                  2
                 </td>
                 <td>
                  PROP_OUT::ERROR_NO_ENERGY
                 </td>
                 <td>
                  not enough energy available for acceleration
                 </td>
                </tr>
                </table>
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="scanner">2.2.2.3 Scanner</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
                The task of the `scanner cell function' is to determine the cells of its own cluster.
                It provides the relative position and the precise internal data of the cells in an iterative procedure.
                The iteration depth is controlled by an index. The algorithm works as follows (the cell on which the scanner points to
                at index i is denoted by C(i)).
                <table border="0">
                 <tr>
                  <td>
                   &#149; index = 0:
                  </td>
                  <td>
                   scanner points to the cell itself, which is C(0)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   &#149; index = 1:
                  </td>
                  <td>
                   scanner points to the cell C(1) where the token which invokes the scan comes from
                  </td>
                 </tr>
                 <tr>
                  <td>
                   &#149; index = 2:
                  </td>
                  <td>
                   scanner points to the cell C(2) which is connected to C(1) and next to C(0) in a clockwise sense
                  </td>
                 </tr>
                 <tr>
                  <td>
                   &nbsp;&nbsp;...
                  </td>
                 </tr>
                 <tr>
                  <td>
                   &#149; index = i:
                  </td>
                  <td>
                   scanner points to the cell C(i) which is connected to C(i-1) and next to C(i-2) in a clockwise sense
                   and different from C(0) to C(i-3)
                  </td>
                 </tr>
                </table>
                <br />
                <br />
                This lookup algorithm is illustrated in the following picture. There, the cell that contains the token (red circle)
                invokes the `scanner cell function'. The token comes from the cell C(1).
                The curved arrows indicate the clockwise search for the next cell.
                We see that the cells are indexed (counterclockwise) in a spiral manner.
                <br />
                <br />
                <img src="qrc:///tutorial/scanner.png" alt="logo" width="300">
                <br />
                <br />
                The `scanner cell function' works with the subsequent byte.
                <br />
                <table border="1">
                 <tr>
                  <th>
                   byte name
                  </th>
                  <th>
                   type
                  </th>
                  <th>
                   description
                  </th>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the state after the process (see below)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_INOUT_CELL_NUMBER
                  </td>
                  <td>
                   input and output byte
                  </td>
                  <td>
                   index i of the cell C(i), value will be incremented after scanning
                   or set to 1 if a ``restart'' takes place
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_MASS
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the mass (number of cells) of the cluster
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_ENERGY
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the energy value of the cell C(i)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_ANGLE
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns CODED_ANGLE(180-alpha) where alpha is the angle (in degree) between the vectors C(i)-C(i-1) and C(i-2)-C(i-1)
                   (see above for a definition of CODED_ANGLE)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_DIST
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns CODED_LEN(len) where len is the distance between C(i-1) and C(i)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_CELL_MAX_CONNECTIONS
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the maximal number of possible connections of cell C(i)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_CELL_BRANCH_NO
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the branch number of cell C(i)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_CELL_FUNCTION
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the cell function of cell C(i) (see below)
                  </td>
                 </tr>
                 <tr>
                  <td>
                   SCANNER_OUT_CELL_FUNCTION_DATA
                  </td>
                  <td>
                   output byte
                  </td>
                  <td>
                   returns the internal data for the cell function of cell C(i) (if the cell has a `computer cell function' it contains the coded instructions)
                  </td>
                 </tr>
                </table>
                <br />
                <br />
                The reason why SCANNER_OUT_ANGLE returns CODED_ANGLE(180-alpha) and not simply
                CODED_ANGLE(alpha) is to be compatible with the 'constructor cell function' (see below).
                <br />
                <br />
                The function CODED_LEN converts a spatial length unit into an 8 bit representation.
                The length 0.0 is mapped to 0 and 1.0 is mapped to 100 (dec).
                Results above 255 are coded as 255.
                <br />
                <br />
                The state of the 'scanner cell function' after processing is stored in SCANNER_OUT, which can attain the following values.
                <br />
                <table border="1">
                <tr>
                 <th>
                  values of SCANNER_OUT
                 </th>
                 <th>
                  symbolic name
                 </th>
                 <th>
                  description
                 </th>
                </tr>
                <tr>
                 <td>
                  0
                 </td>
                 <td>
                  SCANNER_OUT::SUCCESS
                 </td>
                 <td>
                  scanning has been performed
                 </td>
                </tr>
                <tr>
                 <td>
                  1
                 </td>
                 <td>
                  SCANNER_OUT::FINISHED
                 </td>
                 <td>
                  scanning has been performed at last reachable cell
                 </td>
                </tr>
                <tr>
                 <td>
                  2
                 </td>
                 <td>
                  SCANNER_OUT::RESTART
                 </td>
                 <td>
                  scanning has been restarted and performed at C(0) and SCANNER_INOUT_CELL_NUMBER has been set to 1; this happens when i is higher than the number of reachable cells
                 </td>
                </tr>
                </table>
                <br />
                <br />
                The 'cell function' of the scanned cell is stored in SCANNER_OUT_CELL_TYPE and attains the following values.
                <br />
                <table border="1">
                <tr>
                 <th>
                  values of SCANNER_OUT_CELL_FUNCTION
                 </th>
                 <th>
                  symbolic name
                 </th>
                 <th>
                  description
                 </th>
                </tr>
                <tr>
                 <td>
                  0
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::COMPUTER
                 </td>
                 <td>
                  scanned cell has a 'computer cell function'
                 </td>
                </tr>
                <tr>
                 <td>
                  1
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::PROP
                 </td>
                 <td>
                  scanned cell has a 'propulsion cell function'
                 </td>
                </tr>
                <tr>
                 <td>
                  2
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::SCANNER
                 </td>
                 <td>
                  scanned cell has a 'scanner cell function'
                 </td>
                </tr>
                <tr>
                 <td>
                  3
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::WEAPON
                 </td>
                 <td>
                  scanned cell has a 'weapon cell function'
                 </td>
                </tr>
                <tr>
                 <td>
                  4
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::CONSTR
                 </td>
                 <td>
                  scanned cell has a 'construction cell function'
                 </td>
                </tr>
                <tr>
                 <td>
                  5
                 </td>
                 <td>
                  SCANNER_OUT_CELL_FUNCTION::SENSOR
                 </td>
                 <td>
                  scanned cell has a 'sensor cell function'
                 </td>
                </tr>
                </table>
                <br />
                <br />
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="weapon">2.2.2.4 Weapon</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
            If invoked, the `weapon cell function' looks for neighboring cells that are not part of the cluster and in the direct vicinity.
            If such cells are present, a part of their energy amount indicated in <i>[cell properties]->[weaon]->[strength]</i>
            will be `stolen'. One half of the stolen energy amount is tranferred to the invoking token while the half to the cell itself.

            There is no input only one output byte, which is named as WEAPON_OUT and takes the following values.
            <br />
            <table border="1">
            <tr>
             <th>
              values of WEAPON_OUT
             </th>
             <th>
              symbolic name
             </th>
             <th>
              description
             </th>
            </tr>
            <tr>
             <td>
              0
             </td>
             <td>
              WEAPON_OUT::NO_TARGET
             </td>
             <td>
              no neighboring cells have been found
             </td>
            </tr>
            <tr>
             <td>
              1
             </td>
             <td>
              WEAPON_OUT::STRIKE_SUCCESSFUL
             </td>
             <td>
              neighboring cells have been found and attacked
             </td>
            </tr>
            </table>
            <br />
            <br />
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="constructor">2.2.2.5 Constructor</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
            The aim of the 'constructor cell function' (the corresponding cell will be denoted as `constructor') is not only to create a new cell
            but also to bond and create new cell structures.
            To this end, a part of the surrounding of the cell is be taken as a construction site.
            When the constructor creates a new cell the whole construction site will be moved and rotated
            if necessary (the remaining part as well) in order to obtain free space for the new cell. This may take several processing steps.
            When this is completed the new desired cell is placed and bonded to the construction site.
            The constructor can be seen as an artificial equivalent to a biological ribosome, which creates and folds
            proteins from amino acides.
            <br />
            A typical situation is illustrated in the subsequent picture.
            <br />
            <br />
            <img src="qrc:///tutorial/constructor.png" alt="logo" width="600">
            <br />
            <br />
            In the next picture a typical construction process is shown.
            <br />
            <br />
            <img src="qrc:///tutorial/constructor2.png" alt="logo" width="700">
            <br />
            <br />
            After this introductory example we are going to explain the programming of the constructor.
            For convenience, most arguments coincide with output bytes of the scanner and thus share the same addresses in the token memory.
            This allows us to use certain output bytes of the scanner directly as input bytes for the constructor
            in order to easily replicate the cluster's own structure.
            The constructor uses the following bytes.
            <br />
            <table border="1">
             <tr>
              <th>
               byte name
              </th>
              <th>
               type
              </th>
              <th>
               description
              </th>
             </tr>
             <tr>
              <td>
               CONSTR_OUT
              </td>
              <td>
               output byte
              </td>
              <td>
               returns the state after the process (see below)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the command (see below)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_OPTION
              </td>
              <td>
               input byte
              </td>
              <td>
               additional parameters for construction (see below)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_INOUT_ANGLE
               (address coincides with SCANNER_OUT_ANGLE)
              </td>
              <td>
               input and output byte
              </td>
              <td>
               contains CODED_ANGLE(alpha) where alpha is the angle of which the construction site should still be rotated
               (see above for a definition of CODED_ANGLE)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_DIST
               (address coincides with SCANNER_OUT_DIST)
              </td>
              <td>
               input byte
              </td>
              <td>
               CODED_LEN(len)
               where len is the distance of which the
               the construction site should be moved
               (see CODED_LEN from 'scanner cell function')
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_CELL_MAX_CONNECTIONS
               (address coincides with SCANNER_OUT_CELL_MAX_CONNECTIONS)
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the maximal number of possible connections for the new cell;
               if 0 then the maximal number of connections will be automatically determined
               such that no further connections will be possible
               (recommended as standard setting)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_CELL_BRANCH_NO
               (address coincides with SCANNER_OUT_CELL_BRANCH_NO)
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the branch number
               for the new cell
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_CELL_FUNCTION
               (address coincides with SCANNER_OUT_CELL_FUNCTION)
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the cell function
               for the new cell (same values as SCANNER_OUT_CELL FUNCTION)
              </td>
             </tr>
             <tr>
              <td>
               CONSTR_IN_CELL_FUNCTION_DATA
               (address coincides with SCANNER_OUT_CELL_FUNCTION_DATA)
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the internal data for the cell function
               for the new cell
              </td>
             </tr>
            </table>
            <br />
            <br />
            The output byte CONSTR_OUT has one of the following values.
            <br />
            <table border="1">
            <tr>
             <th>
              values of CONSTR_OUT
             </th>
             <th>
              symbolic name
             </th>
             <th>
              description
             </th>
            </tr>
            <tr>
             <td>
              0
             </td>
             <td>
              CONSTR_OUT::SUCCESS
             </td>
             <td>
              construction of a new cell was successful
             </td>
            </tr>
            <tr>
             <td>
              1
             </td>
             <td>
              CONSTR_OUT::SUCCESS_ROT
             </td>
             <td>
              Operation was successful although
              a new cell has not been constructed because
              the construction site needs to be rotated first.
              A part of the rotation has been achieved
              and CONSTR_INOUT_ANGLE has been updated.
              To continue the construction process, the constructor
              should be invoked again with the current token.
             </td>
            </tr>
            <tr>
             <td>
              2
             </td>
             <td>
              CONSTR_OUT::ERROR_NO_ENERGY
             </td>
             <td>
              not enough energy to perform the construction
             </td>
            </tr>
            <tr>
             <td>
              3
             </td>
             <td>
              CONSTR_OUT::ERROR_OBSTACLE
             </td>
             <td>
              construction could not be performed because of
              overlapping cells (i.e. obstacle(s))
             </td>
            </tr>
            <tr>
             <td>
              4
             </td>
             <td>
              CONSTR_OUT::ERROR_CONNECTION
             </td>
             <td>
              construction site is connected to the remaing cluster besides the constructor
             </td>
            </tr>
            <tr>
             <td>
              5
             </td>
             <td>
              CONSTR_OUT::ERROR_DIST
             </td>
             <td>
              CONSTR_IN_DIST is too large (which means that their value converted to spatial units exceeds <i>[cell properties]->[max distance]</i>)
             </td>
            </tr>
            </table>
            <br />
            <br />
            The following commands are possible.
             <br />
             <table border="1">
             <tr>
              <th>
               values of CONSTR_IN
               <br />
               (modulo 4)
              </th>
              <th>
               symbolic name
              </th>
              <th>
               description
              </th>
             </tr>
             <tr>
              <td>
               0
              </td>
              <td>
               CONSTR_IN::NOTHING
              </td>
              <td>
               do nothing
              </td>
             </tr>
             <tr>
              <td>
               1
              </td>
              <td>
               CONSTR_IN::SAFE
              </td>
              <td>
               move construction site and construct new cell
               only if there are no overlapping cells including the cluster's own cells
              </td>
             </tr>
             <tr>
              <td>
               2
              </td>
              <td>
               CONSTR_IN::UNSAFE
              </td>
              <td>
               move construction site and construct new cell
               only if there are no overlapping cells with other clusters
              </td>
             </tr>
             <tr>
              <td>
               3
              </td>
              <td>
               CONSTR_IN::BRUTEFORCE
              </td>
              <td>
               rotate and move construction site and construct new cell
               regardless of overlapping cells (which may lead to destruction)
              </td>
             </tr>
             </table>
             <br />
             <br />
             Additionally, the following options are possible.
             <br />
             <table border="1">
             <tr>
              <th>
               values of CONSTR_IN_OPTION
               <br />
               (modulo 7)
              </th>
              <th>
               symbolic name
              </th>
              <th>
               description
              </th>
             </tr>
             <tr>
              <td>
               0
              </td>
              <td>
               CONSTR_IN_OPTION::STANDARD
              </td>
              <td>
               standard construction process
              </td>
             </tr>
             <tr>
              <td>
               1
              </td>
              <td>
               CONSTR_IN_OPTION::CREATE_EMPTY_TOKEN
              </td>
              <td>
               perform cell construction process and
               create an empty token on the new cell
              </td>
             </tr>
             <tr>
              <td>
               2
              </td>
              <td>
               CONSTR_IN_OPTION::CREATE_DUP_TOKEN
              </td>
              <td>
               perform cell construction process and
               create a copy of the current token on the new cell
              </td>
             </tr>
             <tr>
              <td>
               3
              </td>
              <td>
               CONSTR_IN_OPTION::FINISH_NO_SEP
              </td>
              <td>
               perform cell construction process and
               finalize the construction size but let them connected to
               the constructor
              </td>
             </tr>
             <tr>
              <td>
               4
              </td>
              <td>
               CONSTR_IN_OPTION::FINISH_WITH_SEP
              </td>
              <td>
               perform cell construction process,
               finalize the construction size and disconnect it from the constructor
              </td>
             </tr>
             <tr>
              <td>
               5
              </td>
              <td>
               CONSTR_IN_OPTION::FINISH_WITH_SEP_RED
              </td>
              <td>
               perform cell construction process,
               finalize the construction size and disconnect it from the constructor,
               reduce number of maximal connections of the cell that becomes disconnected from the constructor by 1
              </td>
             </tr>
             <tr>
              <td>
               6
              </td>
              <td>
               CONSTR_IN_OPTION::FINISH_TOKEN_WITH_SEP_RED
              </td>
              <td>
               perform cell construction process,
               finalize the construction size and disconnect it from the constructor,
               reduce number of maximal connections of the cell that becomes disconnected from the constructor by 1,
               create empty token
              </td>
             </tr>
             </table>
             <br />
             <br />
             The construction procedure works in the following way (compare with the illustration above): When the token first invokes the constructor
             it will rotate the construction site and the remaining part (contrariwise) around the constructor
             in order to reach the specified angle in CONSTR_INOUT_ANGLE.
             When the whole cell cluster or the angle is large this process may take several steps and, in this case,
             the constructor performs only a partial rotation and returns the remaining angle in CONSTR_INOUT_ANGLE.
             After invoking the constructor with the resulting token again and again it will finish the rotation.
             Then the construction site will be shifted with a distance specified in CONSTR_IN_DIST and a new cell will be created and connected to the constructor.
             The new cell will also bond to neighboring cells in the construction site (the maximal number of connections are speficied in CONSTR_IN_CELL_MAX_CONNECTIONS).
             We remark that the token on the constructor cannot pass to the construction site because the token passage is blocked
             in this situation.
             For the completion of the construction process (see CONSTR_IN_OPTION) the construction site will be disconnected from the constructor.
            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="sensor">2.2.2.6 Sensor</h2></p>
        </font>
        <font face="Courier" color="#FFFFFF" size="4">
            <p>
            The task of the `sensor cell function' is to detect other cell clusters in the vicinity.
            There are essentially two different modes.
            In the first mode (called mode I in the following) the sensor scans a particular direction up to a certain distance
            (specified by <i>[cell function properties]->[sensor]->[range]</i>)
            and, if successful, returns the distance of the closest other cell cluster.
            In the second mode (mode II) the sensor scans its whole vicinity to detect a cell cluster.
            If successful it returns the angle and the distance of that cluster.
            In both modes a minimum and a maximum mass for detection can be specified in advance.
            The mass corresponds to the number of cells of a cluster.
            The sensor uses the following bytes.
            <br />
            <table border="1">
             <tr>
              <th>
               byte name
              </th>
              <th>
               type
              </th>
              <th>
               description
              </th>
             </tr>
             <tr>
              <td>
               SENSOR_OUT
              </td>
              <td>
               output byte
              </td>
              <td>
               returns the state after the process (see below)
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_IN
              </td>
              <td>
               input byte
              </td>
              <td>
               contains the command (see below)
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_INOUT_ANGLE
              </td>
              <td>
               input and output byte
              </td>
              <td>
               CODED_ANGLE(alpha) where
               in mode I alpha specifies the angle for scanning (input byte);
               in mode II alpha contains the angle in which a cell cluster has been found (output byte)
               (see above for a definition of CODED_ANGLE)
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_IN_MIN_MASS
              </td>
              <td>
               input byte
              </td>
              <td>
               minimum mass of the cell clusters to detect
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_IN_MAX_MASS
              </td>
              <td>
               input byte
              </td>
              <td>
               maximum mass of the cell clusters to detect
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_OUT_MASS
              </td>
              <td>
               output byte
              </td>
              <td>
               mass of the detected cell cluster;
               it has the values 127 if the mass is above 127
              </td>
             </tr>
             <tr>
              <td>
               SENSOR_OUT_DIST
              </td>
              <td>
               output byte;
               it has the values 127 if the distance is above 127
              </td>
              <td>
               distance of the detected cell cluster
              </td>
             </tr>
            </table>
            <br />
            <br />
            The output byte SENSOR_OUT has one of the following values.
            <br />
            <table border="1">
            <tr>
             <th>
              values of SENSOR_OUT
             </th>
             <th>
              symbolic name
             </th>
             <th>
              description
             </th>
            </tr>
            <tr>
             <td>
              0
             </td>
             <td>
              SENSOR_OUT::NOTHING_FOUND
             </td>
             <td>
              sensor has nothing found
             </td>
            </tr>
            <tr>
             <td>
              1
             </td>
             <td>
              SENSOR_OUT::CLUSTER_FOUND
             </td>
             <td>
              sensor has detected an other cell cluster;
              its mass is stored in SENSOR::OUT_MASS,
              its distance in SENSOR::OUT_DIST
              and its angle in SENSOR::INOUT_ANGLE
             </td>
            </tr>
            </table>
            <br />
            <br />
            A sensor can process the following commands.
             <br />
             <table border="1">
             <tr>
              <th>
               values of SENSOR_IN
               <br />
               (modulo 5)
              </th>
              <th>
               symbolic name
              </th>
              <th>
               description
              </th>
             </tr>
             <tr>
              <td>
               0
              </td>
              <td>
               SENSOR_IN::DO_NOTHING
              </td>
              <td>
               do nothing
              </td>
             </tr>
             <tr>
              <td>
               1
              </td>
              <td>
               SENSOR_IN::SEARCH_VICINITY
              </td>
              <td>
               It invokes a wide-area scan for other cell clusters in all directions of the vicinity
               with radius specified in <i>[cell function properties]->[sensor]->[range]</i>.
               If a cell cluster is found with mass between SENSOR_IN_MIN_MASS and SENSOR_IN_MAX_MASS
               (then SENSOR_OUT is set to SENSOR_OUT::CLUSTER_FOUND) its
               angle is returned in SENSOR_INOUT_ANGLE, its distance in SENSOR_OUT_DIST
               and its mass in SENSOR_OUT_MASS.
               Note that it is not guaranteed that all clusters can be detected in this way since the sensor
               uses a certain raster. The raster length is given by sqrt(SENSOR_IN_MIN_MASS)+3.
              </td>
             </tr>
             <tr>
              <td>
               2
              </td>
              <td>
               SENSOR_IN::SEARCH_BY_ANGLE
              </td>
              <td>
               invokes a scan for other cell clusters in a particular direction specified by the angle
               in SENSOR_INOUT_ANGLE; output behavior is similar to SENSOR_IN::SEARCH_VICINITY
              </td>
             </tr>
             <tr>
              <td>
               3
              </td>
              <td>
               SENSOR_IN::SEARCH_FROM_CENTER
              </td>
              <td>
              invokes a scan for other cell clusters in the direction given by the vector posCell - posMassCenter where
              posMassCenter denotes position of the mass center of the current cell cluster and posCell the position of the invoked cell;
              output behavior is similar to SENSOR_IN::SEARCH_VICINITY
              </td>
             </tr>
             <tr>
              <td>
               4
              </td>
              <td>
               SENSOR_IN::SEARCH_TOWARD_CENTER
              </td>
              <td>
              invokes a scan for other cell clusters in the direction given by the vector posMassCenter - posCell (cf. above);
              output behavior is similar to SENSOR_IN::SEARCH_VICINITY
              </td>
             </tr>
             </table>
             <br />
             <br />

            </p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="energyguidance">2.3 Energy guidance system</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="globalparameters">2.4 Global Parameters</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="simulator">3 alien simulator</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="conductingsimulations">3.1 Conducting simulations</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="simulationparameters">3.1.1 Simulation parameters</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="Metadata">3.1.2 Metadata</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="views">3.2 Views and manipulation tools</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="macroview">3.2.1 Macroscopic view</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="microview">3.2.2 Microscopic view</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="celleditor">3.2.2.1 Cell editor</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="tokeneditor">3.2.2.2 Token editor</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="ensembles">3.3 Managing ensembles</h2></p>
        </font>
        <font face="Courier" color="#70B070">
            <p><h2 id="monitoring">3.4 Monitoring</h2></p>
        </font>
    </td> </tr>
    </table>
</body>
</html>
